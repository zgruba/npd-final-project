"""
This module provides various utilities for loading, processing, and analyzing data
from IMDb. It includes functions to calculate movie quality measures, analyze regional impacts, and
compare geopolitical data.
"""

import warnings
from math import isnan
import pandas as pd
from pycountry import countries, historic_countries

# Using filterwarnings to ignore pd.errors.DtypeWarning, types in IMDb are mixed
warnings.filterwarnings(action='ignore', category=pd.errors.DtypeWarning)

# Using filterwarnings to ignore FutureWarning generated by using _get_last
warnings.filterwarnings(action='ignore', category=FutureWarning)

FLOP_TH = 3
MASTERPIECE_TH = 7
VOTE_TH = 100000

QUALITY_MEASURES = {
    'sum_votes': lambda x, **kwargs: sum(x[kwargs['col']]),
    'mean': lambda x, **kwargs: sum(x[kwargs['col']])/len(x),
    'weighted_mean': lambda x, **kwargs: sum(x[kwargs['data']]*x[kwargs['weight']])/sum(x[kwargs['weight']]),
    'flop_prob': lambda x, **kwargs: sum(x[kwargs['col']]<FLOP_TH)/len(x),
    'masterpiece_prob': lambda x, **kwargs: sum(x[kwargs['col']]>MASTERPIECE_TH)/len(x),
    'two-sided': lambda x, **kwargs: (sum(x[kwargs['col']]>MASTERPIECE_TH) - sum(x[kwargs['col']]<FLOP_TH))/len(x)
}

class IMDbData:
    """
    A class to handle loading and preprocessing of movie data.
    
    Attributes:
        title2info (pd.DataFrame): DataFrame containing combined basic and ratings info for titles from IMDb.
        title2reg (pd.DataFrame): DataFrame containing information about the region of origin for titles from IMDb.
    
    Methods:
        title_info_table(): Returns the combined basic and ratings info table.
        title_region_table(): Returns the information table about the region of origin.
    """
    def __init__(self, data_paths: tuple[str, str, str], prod_type: str, in_years: tuple[int, int]):
        """
        Initializes the IMDbData by loading and merging data from different sources.
        
        Args:
            data_path (tuple[str, str, str]): Tuple of path to data (basics_path, akas_path, ratings_path).
            prod_type (str): The type of titles to filter (e.g., 'movie', 'tvEpisode', 'short', 'videoGame').
            in_years (tuple[int, int]): Tuple of ints representing start and end year for filtering titles.
        """
        basics_path, akas_path, ratings_path = data_paths
        title2info, in_type = self.setup_title2info(basics_path, ratings_path, prod_type, in_years)
        title2reg = self.setup_title2reg(akas_path, in_type)

        self.title2info = title2info
        self.title2reg = title2reg

    def title_info_table(self) -> pd.DataFrame:
        """
        Returns the combined basic and ratings info table.
        
        Returns:
            pd.DataFrame: The combined data table.
        """
        return self.title2info

    def title_region_table(self) -> pd.DataFrame:
        """
        Returns the information table about the region of origin.
        
        Returns:
            pd.DataFrame: The information table about the region of origin.
        """
        return self.title2reg

    def setup_title2info(self, basics_path: str, ratings_path: str, prod_type: str, in_years: tuple[int, int]) \
                                                                        -> tuple[pd.DataFrame, pd.DataFrame]:
        """
        Set up the title to information mapping for a specific production type and year range.

        This method loads basic and ratings information from the specified file paths, filters the
        basic information by the production type and year range, and merges the relevant data with
        ratings information.

        Args:
            basics_path (str): The file path to the basic information data.
            ratings_path (str): The file path to the ratings information data.
            prod_type (str): The type of production to filter (e.g., 'movie', 'tvEpisode', 'short', 'videoGame').
            in_years (tuple[int, int]): (the start year of the range to filter,the end year of the range to filter)

        Returns:
            tuple[pd.DataFrame, pd.DataFrame]: A tuple containing two DataFrames:
                - title2info: A DataFrame with the merged basic and ratings information for the filtered titles.
                - in_type: A DataFrame with the filtered titles (tconst) for the specified production type and year range.
        """
        basic_info = load_data(basics_path, usecols=['tconst', 'genres', 'titleType', 'startYear'])
        basic_info_type = basic_info[basic_info['titleType'] == prod_type]
        in_type = basic_info_type[basic_info_type['startYear'].isin([str(x) for x in range(in_years[0], in_years[1]+1)])]
        in_type_filter = in_type['tconst']
        ratings_info = load_data(ratings_path, usecols=['tconst', 'numVotes', 'averageRating'])
        merged_info = pd.merge(basic_info, ratings_info, on='tconst')
        title2info = pd.merge(in_type_filter, merged_info, on='tconst')
        return title2info, in_type_filter

    def setup_title2reg(self, akas_path: str, in_type: pd.DataFrame) -> pd.DataFrame:
        """
        Set up the title to region mapping for a specific set of titles.

        This method loads akas information from the specified file path, filters it by the
        provided titles, and creates a mapping of titles to regions of the origin.

        Args:
            akas_path (str): The file path to the akas information data.
            in_type (pd.DataFrame): A DataFrame containing the filtered titles (tconst) 
            for which the region information is to be mapped.

        Returns:
            pd.DataFrame: A DataFrame with the mapping of titles (tconst) to regions.
        """
        akas_info = load_data(akas_path, usecols=['titleId','title','region','isOriginalTitle'])
        akas_info = akas_info.rename(columns={'titleId': "tconst"})
        akas_in_type = pd.merge(in_type, akas_info, on='tconst')
        org_titles = akas_in_type[akas_in_type['isOriginalTitle'] == 1][['tconst', 'title']]
        prepared_akas = akas_in_type[akas_in_type['isOriginalTitle'] == 0][["tconst", 'title', 'region']]
        title2reg = pd.merge(org_titles, prepared_akas, on=["title", "tconst"])[["tconst", 'region']]
        return title2reg


def load_data(file, delim='\t', usecols=None) -> pd.DataFrame:
    """
    Loads data from a file into a pandas DataFrame.
    
    Args:
        file (str): Path to the data file.
        delim (str): Delimiter used in the data file.
        usecols (list, optional): List of columns to read from the file.
    
    Returns:
        pd.DataFrame: The loaded data as a DataFrame.
    """
    print(f"Loading {file}...")
    dataframe = pd.read_csv(file, delimiter=delim, usecols=usecols)
    print("Loaded")
    return dataframe

def create_representation(dc: IMDbData, repr_size: int, vote_treshold=VOTE_TH) -> pd.DataFrame:
    """
    Creates a representation table of top-rated movies based on average ratings.
    
    Args:
        dc (IMDbData): An instance of the IMDbData.
        repr_size (int): Number of top movies to include in the representation.
        vote_treshold (int, optional): Minimum number of votes required for a movie to be included.
    
    Returns:
        pd.DataFrame: The representation table of top-rated movies.
    """
    rating_movies = dc.title_info_table()[['tconst','averageRating', 'numVotes']]
    if vote_treshold is not None:
        rating_movies = rating_movies[rating_movies['numVotes'] > vote_treshold]
    rating_movies.sort_values('averageRating', ascending=False, inplace=True)
    representation = rating_movies.head(repr_size)
    return representation

def get_top_countries(dc: IMDbData, representation_table: pd.DataFrame,  qm: str, **kwargs) -> pd.DataFrame:
    """
    Gets the top countries based on a specified quality measure.
    
    Args:
        dc (IMDbData): An instance of the IMDbData.
        representation_table (pd.DataFrame): The representation table of top-rated movies.
        qm (str): The quality measure to use for ranking countries.
        **kwargs: Additional keyword arguments for the quality measure function.
    
    Returns:        except ValueError:
            raise ValueError('Invalid format. One of required columns missing.')
        pd.DataFrame: The top countries based on the quality measure.
    """
    title2reg = dc.title_region_table()
    title2reg_with_rating = pd.merge(title2reg, representation_table, on="tconst")

    top_countries = _apply_measure(title2reg_with_rating, ['region', 'numVotes', 'averageRating'], ['region'], qm, **kwargs)
    top_countries_renamed = _region_country_change(top_countries)

    top_countries_renamed.sort_values(qm, ascending=False, inplace=True)
    result = top_countries_renamed.head(10)
    return result

def movies_quality(dc: IMDbData, repr_size: int, qm: str, vote_treshold=VOTE_TH, output_path=None, **kwargs) -> pd.DataFrame:
    """
    Computes and saves the quality of movies by country.
    
    Args:
        dc (IMDbData): An instance of the IMDbData.
        repr_size (int): Number of top movies to include in the representation.
        qm (str): The quality measure to use for ranking countries.
        vote_treshold (int, optional): Minimum number of votes required for a movie to be included.
        output_path (str, optional): Path to save the output CSV file.
        **kwargs: Additional keyword arguments for the quality measure function.
    
    Returns:
        pd.DataFrame: The resulting DataFrame of top countries by movie quality.
    """
    representation = create_representation(dc, repr_size, vote_treshold)
    result = get_top_countries(dc, representation, qm, **kwargs)
    if output_path is not None:
        result.to_csv(output_path, index=False)
    else:
        result.to_csv(f"out/task1_repr_{repr_size}_th_{vote_treshold}_{qm}.csv", index=False)
    return result

def weak_impact(dc: IMDbData) -> pd.DataFrame:
    """
    Computes the weak impact of countries based on the number of votes.
    
    Args:
        dc (IMDbData): An instance of the IMDbData.
    
    Returns:
        pd.DataFrame: The weak impact of countries.
    """
    title2reg = dc.title_region_table()
    title2rating = dc.title_info_table()[['tconst','averageRating', 'numVotes']]
    title2reg_with_rating = pd.merge(title2reg, title2rating, on="tconst")

    wi = _apply_measure(title2reg_with_rating, ['region', 'numVotes'], ['region'], 'sum_votes', col='numVotes')
    wi = _region_country_change(wi)
    return wi

def strong_impact(dc: IMDbData, qm: str, **kwargs) -> pd.DataFrame:
    """
    Computes the strong impact of countries based on a specified quality measure.
    
    Args:
        dc (IMDbData): An instance of the IMDbData.
        qm (str): The quality measure to use for ranking countries.
        **kwargs: Additional keyword arguments for the quality measure function.
    
    Returns:
        pd.DataFrame: The strong impact of countries.
    """
    title2reg = dc.title_region_table()
    title2rating = dc.title_info_table()[['tconst','averageRating', 'numVotes']]
    title2reg_with_rating = pd.merge(title2reg, title2rating, on="tconst")

    si = _apply_measure(title2reg_with_rating, ['region', 'numVotes', 'averageRating'], ['region'], qm, **kwargs)
    si = _region_country_change(si)
    return si

def split_star_countries(df: pd.DataFrame) -> tuple[pd.DataFrame, pd.DataFrame]:
    """
    Splits countries into starred (historical/unidentified) and regular based on the first character of the country code.
    
    Args:
        df (pd.DataFrame): The DataFrame containing country information.
    
    Returns:
        tuple[pd.DataFrame, pd.DataFrame]: Two DataFrames - one for starred countries and one for regular countries.
    """
    stars = df[df['country'].str[0] == "*"]
    regulars = df[df['country'].str[0] != "*"]
    return (regulars, stars)

def geopolitical_data(population_path: str, gdp_path: str, per_capita_path: str) -> pd.DataFrame:
    """
    Loads and merges geopolitical data from different sources.
    
    Args:
        population_path (str): Path to the population CSV file with column "Country Code"\
             with ISO 3166-1 and columns representing years.
        gdp_path (str): Path to the GDP CSV file with column "Country Code"\
             with ISO 3166-1 and columns representing years.
        per_capita_path (str): Path to the per capita CSV file with column "Country Code"\
         with ISO 3166-1 and columns representing years.
    
    Returns:
        pd.DataFrame: The merged geopolitical data.
    """
    population = load_data(population_path, delim=',')
    gdp = load_data(gdp_path, delim=',')
    per_capita = load_data(per_capita_path, delim=',')

    years = set(list(population.columns) + list(gdp.columns) + list(per_capita.columns))
    years = {_str_to_int(col) for col in years} - {""}
    years = [str(x) for x in  sorted(list(years))]

    population['pop'] = population[years].agg(_get_last, axis=1)
    gdp['gdp'] = gdp[years].agg(_get_last, axis=1)
    per_capita['pc'] = per_capita[years].agg(_get_last, axis=1)

    population = population[["Country Code", 'pop']]
    gdp = gdp[["Country Code", 'gdp']]
    per_capita = per_capita[["Country Code", 'pc']]

    result = pd.merge(population, gdp, on="Country Code")
    result = pd.merge(result, per_capita, on="Country Code")

    result['country'] = result['Country Code'].map(_code_to_country)
    result = result[result['country'] != ""]
    return result[['country', 'pop', 'gdp', 'pc']]

def impact_vs_data(impact_df: pd.DataFrame, impact_col: str, data_df: pd.DataFrame, data_col: str, output_path = None):
    """
    Compares impact data with geopolitical data and saves the result.
    
    Args:
        impact_df (pd.DataFrame): The DataFrame containing impact data.
        impact_col (str): The column in the impact data to compare.
        data_df (pd.DataFrame): The DataFrame containing geopolitical data.
        data_col (str): The column in the geopolitical data to compare.
        output_path (str, optional): Path to save the output CSV file.
    """
    data_rating = data_df.sort_values(data_col, ascending = False)
    impact_rating = impact_df.sort_values(impact_col, ascending=False)

    data_rating['dataRating'] = data_rating[data_col].rank(method='dense', ascending=False)
    impact_rating['impactRating'] = impact_rating[impact_col].rank(method='dense', ascending=False)

    result = pd.merge(impact_rating, data_rating, on='country')
    result['difference'] = result['dataRating'] - result['impactRating']
    result = result[['country', 'impactRating', 'dataRating', 'difference']].sort_values('difference', ascending=False)

    if output_path is not None:
        result.to_csv(output_path, index=False)
    else:
        result.to_csv(f"out/task2_{impact_col}_to_{data_col}.csv", index=False)

def region_genre_analysis(dc: IMDbData, qm: str, output_path=None, **kwargs) -> pd.DataFrame:
    """
    Analyzes region and genre data based on a specified quality measure.
    
    Args:
        dc (IMDbData): An instance of the IMDbData.
        qm (str): The quality measure to use for analysis.
        output_path (str, optional): Path to save the output CSV file.
        **kwargs: Additional keyword arguments for the quality measure function.
    
    Returns:
        pd.DataFrame: The resulting DataFrame of the analysis.
    """
    title2info = dc.title_info_table()
    title2reg = dc.title_region_table()
    title2info = title2info[title2info['genres'] != "\\N"]
    title2info = title2info.assign(genre=title2info['genres'].str.split(',')).explode('genre').reset_index(drop=True)
    merged = pd.merge(title2reg, title2info, on="tconst")
    final_table = _apply_measure(merged, ['region', 'numVotes', 'averageRating', 'genre'], ['region', 'genre'], qm, **kwargs)
    final_table = _region_country_change(final_table)
    result = final_table.sort_values(qm, ascending=False)

    if output_path is not None:
        result.to_csv(output_path, index=False)
    else:
        result.to_csv(f"out/task3_{qm}_country_vs_genre.csv", index=False)

    return result

def make_comparison(coun_vs_gen: pd.DataFrame, country_set: set[str] | None, genre_set: set[str] | None,\
                                                                     output_path=None) -> pd.DataFrame:
    """
    Makes a comparison of countries and genres and saves the result.
    
    Args:
        coun_vs_gen (pd.DataFrame): The DataFrame containing country and genre data.
        country_set (set): The set of countries to include in the comparison.
        genre_set (set): The set of genres to include in the comparison.
        output_path (str, optional): Path to save the output CSV file.
    
    Returns:
        pd.DataFrame: The resulting DataFrame of the comparison.
    """
    if country_set is not None:
        coun_vs_gen = coun_vs_gen[coun_vs_gen['country'].isin(country_set)]
    if genre_set is not None:
        coun_vs_gen = coun_vs_gen[coun_vs_gen['genre'].isin(genre_set)]

    if output_path is not None:
        coun_vs_gen.to_csv(output_path, index=False)
    else:
        if country_set is not None and genre_set is not None:
            coun_vs_gen.to_csv(f"out/comparison_{'_'.join(list(country_set))}_{'_'.join(list(genre_set))}.csv", index=False)
        elif country_set is not None:
            coun_vs_gen.to_csv(f"out/comparison_{'_'.join(list(country_set))}.csv", index=False)
        elif genre_set is not None:
            coun_vs_gen.to_csv(f"out/comparison_{'_'.join(list(genre_set))}.csv", index=False)
        else:
            coun_vs_gen.to_csv("out/comparison_full.csv", index=False)

    return coun_vs_gen

# Helper function to apply a quality measure
def _apply_measure(df:pd.DataFrame, col_taken: list[str],  group_by: list[str], qm: str, **kwargs) -> pd.DataFrame:
    fun = QUALITY_MEASURES[qm] if isinstance(qm, str) else qm
    applied = df[col_taken].groupby(group_by, as_index=False).apply(fun, **kwargs)
    applied.columns = [qm if col is None else col for col in applied.columns]
    return applied

# Helper function to map region codes to country names
def _region_country_change(df: pd.DataFrame) -> pd.DataFrame:
    df['region'] = df['region'].map(_code_to_country)
    df.rename(columns={'region':'country'}, inplace=True)
    return df

# Helper function to convert country codes to country names
def _code_to_country(x: str) -> str:
    size = len(x)
    kwargs = {f"alpha_{size}": x}

    if x == "":
        return ""

    try:
        v = countries.get(**kwargs)
        if v is not None:
            return v.name
    except KeyError:
        pass

    try:
        v = historic_countries.get(**kwargs)
        if v is not None:
            return "*" + v.name
    except KeyError:
        pass

    if x[0] == "X":
        return "**" + x

    return ""

# Helper function to convert string to integer
def _str_to_int(x):
    try:
        return str(int(x))
    except ValueError:
        return ""

# Helper function to get the last non-NaN value
def _get_last(x):
    for el in reversed(x):
        if not isnan(el):
            return el
    return 0.0
